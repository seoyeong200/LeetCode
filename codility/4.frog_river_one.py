"""
문제 이해하는데 진짜 개오래걸림...

위치 0애서 위치 X+1까지 이동하는게 목표
길이 N 배열 A 주어지고 각 배열 원소는 인덱스 time(초)에 잎이 떨어지는 위치를 나타낸다.
- A[i] = i초에 잎 떨어지는 위치 (1<=A[i]<=X)
1부터 X까지 모든 위치에 잎이 있을때 개구리가 건너갈 수 있다.
건너갈 수 있는 시간의 최솟값 구하기
0 1 2 3 4 5 6 7 초에
1 3 1 4 2 3 5 4 에 잎 떨어짐

X가 나오는 A의 가장 작은 인덱스를 찾으면 될 것 같았는데, 이렇게 하면 해당 시점에 아직 앞에 나뭇잎이 다 안깔려있을 수도 있다.
X가 나오는 시점에 1~X-1 의 배열이 다 1인지 확인해야한다.
- X가 나왔을때
    - 앞에 나뭇잎 다 있는 경우 (=check에 1부터 X까지의 값이 다 존재) -> 바로 리턴
    - 앞에 나뭇잎 없는 경우
        - 이후 다 채워지는 순간 리턴해야함

그니까 그냥 set으로 1부터 X 만들어놓고 A 돌면서 하나씩 삭제한다. 다 비워지는 시점에 리턴해버리기
"""
def solution(X, A):
    check = set([i for i in range(1, X+1)]) # 1부터 X-1까지 잎 깔려있는지 확인하는 배열

    for i, pos in enumerate(A):
        check.discard(pos)
        if len(check) == 0: 
            return i

    return -1